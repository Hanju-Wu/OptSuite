#include "OptSuite/Utils/json_formatter.h"
#include "OptSuite/Base/structure.h"
#include "OptSuite/Base/cell_array.h"

namespace {
    // https://stackoverflow.com/questions/7369344/how-to-unescape-strings-in-c-c

    /*
    ** Does not generate hex character constants.
    ** Always generates triple-digit octal constants.
    ** Always generates escapes in preference to octal.
    ** Escape question mark to ensure no trigraphs are generated by repetitive use.
    ** Handling of 0x80..0xFF is locale-dependent (might be octal, might be literal).
    */

    char* chr_cstrlit(unsigned char u, char *buffer, size_t buflen)
    {
        if (!buffer || buflen <= 0) { return nullptr; }

        if (buflen < 2)
            *buffer = '\0';
        else if (isprint(u) && u != '\'' && u != '\"' && u != '\\' && u != '\?')
            sprintf(buffer, "%c", u);
        else if (buflen < 3)
            *buffer = '\0';
        else
        {
            switch (u)
            {
            case '\a':  strcpy(buffer, "\\a"); break;
            case '\b':  strcpy(buffer, "\\b"); break;
            case '\f':  strcpy(buffer, "\\f"); break;
            case '\n':  strcpy(buffer, "\\n"); break;
            case '\r':  strcpy(buffer, "\\r"); break;
            case '\t':  strcpy(buffer, "\\t"); break;
            case '\v':  strcpy(buffer, "\\v"); break;
            case '\\':  strcpy(buffer, "\\\\"); break;
            case '\'':  strcpy(buffer, "\\'"); break;
            case '\"':  strcpy(buffer, "\\\""); break;
            case '\?':  strcpy(buffer, "\\\?"); break;
            default:
                if (buflen < 5)
                    *buffer = '\0';
                else
                    sprintf(buffer, "\\%03o", u);
                break;
            }
        }
        return buffer + strlen(buffer);
    }

    char* str_cstrlit(const char *str, char *buffer, size_t buflen)
    {
        if (!buffer || buflen <= 0) { return nullptr; }
        unsigned char u;
        size_t len;

        while ((u = (unsigned char)*str++) != '\0')
        {
            char* new_buffer = chr_cstrlit(u, buffer, buflen);
            len = new_buffer - buffer;
            if (len  == 0)
                return buffer;
            buffer += len;
            buflen -= len;
        }
        *buffer = '\0';
        return buffer;
    }
}

namespace OptSuite { namespace Utils {
    using namespace OptSuite::Base;

    std::string JsonFormatter::format(const Index& i) const {
        return std::to_string(i);
    }

    std::string JsonFormatter::format(const Scalar& d) const {
        constexpr int dsize = std::numeric_limits<Scalar>::max_digits10;
        if (!std::isfinite(d)) {
            return "null";
        }
        if (buff_.size() < dsize * 2) {
            // unreachable, as the initial size should exceed dsize * 2
            buff_.resize(dsize * 4);
        }
        snprintf(buff_.data(), buff_.size(), "%.*g", dsize, d);
        return std::string(buff_.data());
    }

    std::string JsonFormatter::format(const bool& b) const {
        return b ? "true" : "false";
    }

    std::string JsonFormatter::format(const std::string& s) const {
        if (buff_.size() < s.size() * 4 + 4) {
            buff_.resize(s.size() * 8 + 4);
        }
        buff_.data()[0] = '"';
        char* endbuff = str_cstrlit(s.data(), buff_.data() + 1, buff_.size() - 2);
        endbuff[0] = '"';
        endbuff[1] = '\0';
        return std::string(buff_.data());
    }

    std::string JsonFormatter::format_impl(const Structure& st, Index indent_level) const {
        std::string ans = "{\n";
        ++indent_level;

        if (buff_.size() < 80) {
            buff_.resize(80);
        }

        for (const auto& kvpair : st) {
            ans += std::string(indent_level * indent_size(), ' ');

            ans += format(kvpair.first);
            ans += ": ";
            ans += format_generic(kvpair.second.get(), indent_level);

            ans += ",\n";
        }

        // remove "",\n" at the last entry
        ans.pop_back();
        ans.pop_back();

        ans += "\n";
        --indent_level;
        ans += std::string(indent_level * indent_size(), ' ');
        ans += "}";

        return ans;
    }

    std::string JsonFormatter::format_impl(const CellArray& ca, Index indent_level) const {
        std::string ans = "[\n";
        ++indent_level;

        if (buff_.size() < 80) {
            buff_.resize(80);
        }

        for (const auto& value : ca) {
            ans += std::string(indent_level * indent_size(), ' ');
            ans += format_generic(value.get(), indent_level);
            ans += ",\n";
        }

        // remove "",\n" at the last entry
        ans.pop_back();
        ans.pop_back();

        ans += "\n";
        --indent_level;
        ans += std::string(indent_level * indent_size(), ' ');
        ans += "]";

        return ans;
    }

    std::string JsonFormatter::format_generic(const OptSuiteBase* obj, Index indent_level) const {
        if (!obj) {
            return "null";
        }

        auto d = dynamic_cast<const ScalarWrapper<Scalar>*>(obj);
        if (d) {
            return format(d->data());
        }

        auto s = dynamic_cast<const ObjectWrapper<std::string>*>(obj);
        if (s) {
            return format(s->data());
        }

        auto b = dynamic_cast<const ScalarWrapper<bool>*>(obj);
        if (b) {
            return format(b->data());
        }

        auto i = dynamic_cast<const ObjectWrapper<Index>*>(obj);
        if (i) {
            return format(i->data());
        }

        auto st = dynamic_cast<const ObjectWrapper<Structure>*>(obj);
        if (st) {
            return format_impl(st->data(), indent_level);
        }

        auto ca = dynamic_cast<const ObjectWrapper<CellArray>*>(obj);
        if (ca) {
            return format_impl(ca->data(), indent_level);
        }

        OPTSUITE_ASSERT_MSG(false, "Unsupported value type");
        return "";
    }
}}
